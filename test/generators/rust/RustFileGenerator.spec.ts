import * as path from 'path';
import {
  RustFileGenerator, FileHelpers,
  OutputModel, CommonInputModel, CommonModel, defaultRustRenderCompleteModelOptions, RustRenderCompleteModelOptions
} from '../../../src';
import { RustOutputModel } from '../../../src/generators/rust/RustOutput';

describe('RustFileGenerator', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('generateToFile()', () => {
    const doc = {
      $id: 'CustomClass',
      type: 'object',
      additionalProperties: true,
      properties: {
        someProp: { type: 'string' },
        someEnum: {
          $id: 'CustomEnum',
          type: 'string',
          enum: ['Texas', 'Alabama', 'California'],
        },
        street_name: { type: 'string' },
        city: { type: 'string', description: 'City description' },
        state: { type: 'string' },
        house_number: { type: 'number' },
        members: { oneOf: [{ type: 'string' }, { type: 'number' }, { type: 'boolean' }], },
        array_type: { type: 'array', items: { type: 'string' } },
        required: ['street_name', 'city', 'state', 'house_number', 'array_type'],
      }
    };
    test('should throw accurate error if file cannot be written', async () => {
      const generator = new RustFileGenerator();
      const expectedError = new Error('write error');
      const expectedFilename = 'src/Test.rs';
      jest.spyOn(FileHelpers, 'writerToFileSystem').mockRejectedValue(expectedError);
      jest.spyOn(generator, 'generateCompleteModels').mockResolvedValue([new RustOutputModel('content', new CommonModel(), 'Test', new CommonInputModel(), [], expectedFilename)]);

      await expect(generator.generateToFiles(doc, '/test/', defaultRustRenderCompleteModelOptions)).rejects.toEqual(expectedError);
      expect(generator.generateCompleteModels).toHaveBeenCalledTimes(1);
      expect(FileHelpers.writerToFileSystem).toHaveBeenCalledTimes(1);
    });
    test('should not generate supporting files', async () => {
      const generator = new RustFileGenerator();
      const outputDir = './test';
      const expectedFilename = 'src/Test.rs';

      const expectedOutputDirPath = path.resolve(outputDir);
      const expectedOutputFilePath = path.resolve(`${outputDir}/${expectedFilename}`);
      const expectedWriteToFileParameters = [
        ['content',
          expectedOutputFilePath,]];
      jest.spyOn(FileHelpers, 'writerToFileSystem').mockResolvedValue(undefined);
      jest.spyOn(generator, 'generateCompleteModels').mockResolvedValue([new RustOutputModel('content', new CommonModel(), 'Test', new CommonInputModel(), [], expectedFilename)]);

      await generator.generateToFiles(doc, expectedOutputDirPath, { renderSupportingFiles: false } as RustRenderCompleteModelOptions);
      expect(generator.generateCompleteModels).toHaveBeenCalledTimes(1);
      expect(FileHelpers.writerToFileSystem).toHaveBeenCalledTimes(1);
      expect((FileHelpers.writerToFileSystem as jest.Mock).mock.calls[0]).toEqual(expectedWriteToFileParameters[0]);
    });

    test('should try and generate models and supporting files', async () => {
      const generator = new RustFileGenerator();
      const outputDir = './test';
      const expectedFilename = 'src/Test.rs';

      const expectedOutputDirPath = path.resolve(outputDir);
      const expectedOutputFilePath = path.resolve(`${outputDir}/${expectedFilename}`);
      const expectedWriteToFileParameters = [
        ['content',
          expectedOutputFilePath,],
        [`[package]
name = "asyncapi-rs-models"
version = "0.0.0"
authors = ["AsyncAPI Rust Champions"]
homepage = "https://www.asyncapi.com/tools/modelina"
repository = "https://github.com/asyncapi/modelina"
license = "Apache-2.0"
description = "Rust models generated by AsyncAPI Modelina"
edition = "2018"

[dependencies]
jsonwebtoken = {version="7", optional = true }
serde = { version = "1", features = ["derive"] }
serde_json = { version="1", optional = true }
thiserror = "1"

[dev-dependencies]

[features]
default = ["json", "jwt"]
json = ["dep:serde_json"]
jwt = ["dep:jsonwebtoken"]`, path.resolve(`${outputDir}/Cargo.toml`)], [
          `#[macro_use]
extern crate serde;
extern crate serde_json;

pub mod test;
pub use self::test::*;`,
          path.resolve(`${outputDir}/src/lib.rs`)
        ]
      ];
      jest.spyOn(FileHelpers, 'writerToFileSystem').mockResolvedValue(undefined);
      jest.spyOn(generator, 'generateCompleteModels').mockResolvedValue([new RustOutputModel('content', new CommonModel(), 'Test', new CommonInputModel(), [], expectedFilename)]);

      const generatedModels = await generator.generateToFiles(doc, expectedOutputDirPath, { renderSupportingFiles: true } as RustRenderCompleteModelOptions);
      expect(generator.generateCompleteModels).toHaveBeenCalledTimes(1);
      expect(FileHelpers.writerToFileSystem).toHaveBeenCalledTimes(3);
      expect((FileHelpers.writerToFileSystem as jest.Mock).mock.calls[0]).toEqual(expectedWriteToFileParameters[0]);

      await generator.generateSupportFiles(generatedModels, outputDir, defaultRustRenderCompleteModelOptions);
      expect((FileHelpers.writerToFileSystem as jest.Mock).mock.calls[1]).toEqual(expectedWriteToFileParameters[1]);
      expect((FileHelpers.writerToFileSystem as jest.Mock).mock.calls[2]).toEqual(expectedWriteToFileParameters[2]);
    });

    test('should ignore models that have not been rendered', async () => {
      const generator = new RustFileGenerator();
      const outputDir = './test';
      const expectedOutputDirPath = path.resolve(outputDir);
      jest.spyOn(FileHelpers, 'writerToFileSystem').mockResolvedValue(undefined);
      jest.spyOn(generator, 'generateCompleteModels').mockResolvedValue([new RustOutputModel('content', new CommonModel(), '', new CommonInputModel(), [], '')]);
      const models = await generator.generateToFiles(doc, expectedOutputDirPath, { renderSupportingFiles: false } as RustRenderCompleteModelOptions);
      expect(generator.generateCompleteModels).toHaveBeenCalledTimes(1);
      expect(FileHelpers.writerToFileSystem).toHaveBeenCalledTimes(0);
      expect(models).toHaveLength(0);
    });
  });
});
